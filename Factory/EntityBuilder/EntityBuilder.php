<?php

namespace lkovace18\EntityFactoryBundle\Factory\EntityBuilder;

use Dflydev\DotAccessData\Data;
use Doctrine\Common\Persistence\ObjectManager;
use Doctrine\ORM\EntityManager;
use Doctrine\ORM\Mapping\ClassMetadata;
use Doctrine\ORM\Mapping\ClassMetadataInfo;
use lkovace18\EntityFactoryBundle\Factory\EntityBuilder\Associations\ManyToMany;
use lkovace18\EntityFactoryBundle\Factory\EntityBuilder\Associations\ManyToOne;
use lkovace18\EntityFactoryBundle\Factory\EntityBuilder\Associations\OneToMany;
use lkovace18\EntityFactoryBundle\Factory\EntityBuilder\Associations\OneToOne;
use Symfony\Component\PropertyAccess\PropertyAccessor;

/**
 * Class EntityBuilder
 *
 * @package lkovace18\FactoryBundle\Factory\Util
 */
class EntityBuilder
{
    /**
     * @var ObjectManager
     */
    protected $em;

    /**
     * @var PropertyAccessor
     */
    protected $accessor;

    /**
     * @param EntityManager $em
     */
    public function __construct(EntityManager $em)
    {
        $this->em = $em;
        $this->accessor = new PropertyAccessor();
    }

    /**
     * @param       $entity
     * @param array $params
     * @param null  $callback
     *
     * @return object
     */
    public function createEntity($entity, $params = [], $callback = null)
    {
        // @todo rename it to override because it overrides definition
        $params = $this->prepareParams($params);

        $meta = $this->em->getClassMetadata($entity);

        $instance = new $entity;

        foreach ($meta->getFieldNames() as $field) {
            /* skip auto generated fields */
            if ($this->isAutoGeneratedIdField($field, $meta)) {
                continue;
            }

            if ($params->get($field) !== null) {
                $this->accessor->setValue($instance, $field, $params->get($field));
            }
        }

        foreach ($meta->getAssociationNames() as $relation) {
            $this->handleRelation($relation, $meta, $instance, $params);
        }

        if (is_callable($callback)) {
            $instance = $callback($instance);
        }

        return $instance;
    }

    /**
     * @param $params
     *
     * @return Data
     */
    private function prepareParams($params)
    {
        $data = new Data();
        $params = is_array($params) ? $params : [];

        foreach ($params as $path => $value) {
            if (0 == strlen($path)) {
                // @todo handle empty keys
                continue;
            }
            $data->set($path, $value);
        }

        return $data;
    }

    /**
     * @param $field
     * @param $meta
     *
     * @return bool
     */
    protected function isAutoGeneratedIdField($field, ClassMetadata $meta)
    {
        $isIdentifierField = in_array($field, $meta->getIdentifierFieldNames());
        $isAutoGenerated = $meta->generatorType !== ClassMetadata::GENERATOR_TYPE_NONE;

        return $isIdentifierField && $isAutoGenerated;
    }

    /**
     * @param                   $relation
     * @param ClassMetadataInfo $meta
     * @param                   $instance
     * @param Data              $params
     *
     * @throws \Doctrine\ORM\Mapping\MappingException
     */
    private function handleRelation($relation, ClassMetadataInfo $meta, $instance, Data $params)
    {
        $data = $params->get($relation);
        if (is_array($data) && isset($data[0])) {
            foreach ($data as $index => $set) {
                $assoc = $this->getRelationHandler($relation, $meta);
                $assoc->handle($relation, $meta, $instance, new Data([$relation => $set]));
            }
        } else {
            $assoc = $this->getRelationHandler($relation, $meta);
            $assoc->handle($relation, $meta, $instance, $params);
        }
    }

    /**
     * @param                   $association
     * @param ClassMetadata $meta
     *
     * @return ManyToMany|ManyToOne|OneToMany|OneToOne
     * @throws \Doctrine\ORM\Mapping\MappingException
     */
    private function getRelationHandler($association, ClassMetadata $meta)
    {
        $mapping = $meta->getAssociationMapping($association);

        switch ($mapping['type']) {
            case ClassMetadataInfo::ONE_TO_ONE:
                $assoc = new OneToOne($this->accessor, $this);
                break;
            case ClassMetadataInfo::MANY_TO_ONE:
                $assoc = new ManyToOne($this->accessor, $this);
                break;
            case ClassMetadataInfo::ONE_TO_MANY:
                $assoc = new OneToMany($this->accessor, $this);
                break;
            case ClassMetadataInfo::MANY_TO_MANY:
                $assoc = new ManyToMany($this->accessor, $this);
                break;
            default:
                // @todo throw exception ( never expects spanis inquisition )
                $assoc = null;
        }

        return $assoc;
    }
}
